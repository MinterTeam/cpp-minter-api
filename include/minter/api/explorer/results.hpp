#ifndef GEN_EXPLORER_RESULTS
#define GEN_EXPLORER_RESULTS

// AUTOGENERATED header. DO NOT modify manually.
//
#include "minter/api/explorer/base.h"

#include <minter/address.h>
#include <minter/hash.h>
#include <minter/minter_tx_config.h>
#include <minter/public_key.h>
#include <minter/tx/tx_type.h>
#include <nlohmann/json.hpp>
#include <string>
#include <vector>

namespace minter {
namespace explorer {

struct transaction_item {
    dev::bigint txn;
    minter::hash_t hash;
    dev::bigint nonce;
    dev::bigint block;
    std::string timestamp;
    dev::bigdec18 fee;
    minter::tx_type_val type;
    std::string payload;
    minter::address_t from;
    std::shared_ptr<minter::explorer::tx_result> data;
    static ::nlohmann::json _data_encode(nlohmann::json& j, const ::minter::explorer::transaction_item& resp);
    static void _data_decode(const nlohmann::json& j, ::minter::explorer::transaction_item& resp);
};
struct tx_send_result : public minter::explorer::tx_result {
    minter::address_t to;
    std::string coin;
    dev::bigdec18 value;
};
struct tx_create_coin_result : public minter::explorer::tx_result {
    std::string name;
    std::string symbol;
    dev::bigdec18 initial_amount;
    dev::bigdec18 initial_reserve;
    uint32_t crr;
};
struct tx_convert_result : public minter::explorer::tx_result {
    std::string coin_to_sell;
    std::string coin_to_buy;
    dev::bigdec18 value_to_buy;
    dev::bigdec18 value_to_sell;
    dev::bigdec18 maximum_value_to_sell;
    dev::bigdec18 minimum_value_to_buy;
};
struct tx_declare_candidacy_result : public minter::explorer::tx_result {
    minter::address_t address;
    minter::pubkey_t pub_key;
    uint32_t commission;
    std::string coin;
    dev::bigdec18 stake;
};
struct tx_set_candidate_on_off_result : public minter::explorer::tx_result {
    minter::pubkey_t pub_key;
};
struct tx_delegate_unbond_result : public minter::explorer::tx_result {
    minter::pubkey_t pub_key;
    std::string coin;
    dev::bigdec18 stake;
    dev::bigdec18 value;
};
struct tx_check_data_result {
    std::string coin;
    dev::bigint nonce;
    dev::bigdec18 value;
    minter::address_t sender;
    dev::bigint due_block;
};
struct tx_redeem_check_result : public minter::explorer::tx_result {
    std::string raw_check;
    std::string proof;
    dev::bigdec18 stake;
    dev::bigdec18 value;
    tx_check_data_result check;
};
struct tx_create_multisig_result : public minter::explorer::tx_result {
    dev::bigint threshold;
    std::vector<dev::bigint> weights;
    std::vector<minter::address_t> addresses;
};
struct tx_multisend_result : public minter::explorer::tx_result {
    std::vector<tx_send_result> items;
};
struct tx_edit_candidate_result : public minter::explorer::tx_result {
    minter::address_t reward_address;
    minter::address_t owner_address;
    minter::pubkey_t pub_key;
};
struct balance_item {
    std::string coin;
    dev::bigdec18 amount;
};
struct balance_items {
    minter::address_t address;
    std::vector<balance_item> balances;
};
struct delegated_item {
    minter::pubkey_t pub_key;
    std::string coin;
    dev::bigdec18 value;
};
struct reward_item {
    uint64_t block;
    std::string role;
    dev::bigdec18 amount;
    minter::address_t address;
    minter::pubkey_t validator;
    std::string timestamp;
};
struct validator_meta {
    std::string name;
    std::string description;
    std::string site_url;
    std::string icon_url;
};
struct block_validator_item {
    minter::pubkey_t pub_key;
    bool is_signed;
    validator_meta meta;
};
struct block_info_item {
    dev::bigint height;
    size_t size;
    size_t tx_count;
    std::string block_time;
    std::string timestamp;
    dev::bigdec18 reward;
    minter::hash_t hash;
    std::vector<block_validator_item> validators;
};
struct coin_item {
    uint32_t crr;
    dev::bigdec18 volume;
    dev::bigdec18 reserve_valance;
    std::string name;
    std::string ticker;
};
struct validator_item {
    minter::pubkey_t pub_key;
    int status;
    dev::bigdec18 stake;
    dev::bigdec18 part;
    validator_meta meta;
};
struct delegator_item {
    std::string coin;
    minter::address_t address;
    dev::bigdec18 value;
    dev::bigdec18 bip_value;
};
struct validator_detailed_item {
    minter::pubkey_t pub_key;
    int status;
    dev::bigdec18 stake;
    dev::bigdec18 part;
    validator_meta meta;
    uint64_t delegator_count;
    std::vector<delegator_item> delegator_list;
};
struct net_status {
    dev::bigdec18 avg_block_time;
    double bip_price_change;
    double bip_price_usd;
    dev::bigint latest_block_height;
    double bip_market_cap;
    dev::bigint total_txn;
    double tx_per_second;
};
struct net_status_page {
    uint64_t active_candidates;
    uint64_t active_validators;
    dev::bigdec18 avg_tx_commission;
    dev::bigint bip_emission;
    dev::bigdec18 block_speed_24h;
    uint64_t custom_coins_count;
    dev::bigdec18 custom_coins_sum;
    dev::bigdec18 bip_free_float;
    dev::bigint number_of_blocks;
    std::string status;
    dev::bigdec18 total_commission;
    dev::bigdec18 total_delegated_bip;
    dev::bigint tx_24h_count;
    dev::bigdec18 tx_per_second;
    dev::bigint total_txn;
    double uptime;
};
inline void from_json(const nlohmann::json& j, ::minter::explorer::transaction_item& resp) {
    if (j.find("txn") != j.end() && !j.at("txn").is_null())
        j.at("txn").get_to<dev::bigint>(resp.txn);
    if (j.find("hash") != j.end() && !j.at("hash").is_null())
        j.at("hash").get_to<minter::hash_t>(resp.hash);
    if (j.find("nonce") != j.end() && !j.at("nonce").is_null())
        j.at("nonce").get_to<dev::bigint>(resp.nonce);
    if (j.find("block") != j.end() && !j.at("block").is_null())
        j.at("block").get_to<dev::bigint>(resp.block);
    if (j.find("timestamp") != j.end() && !j.at("timestamp").is_null())
        j.at("timestamp").get_to<std::string>(resp.timestamp);
    if (j.find("fee") != j.end() && !j.at("fee").is_null())
        j.at("fee").get_to<dev::bigdec18>(resp.fee);
    if (j.find("type") != j.end() && !j.at("type").is_null())
        j.at("type").get_to<minter::tx_type_val>(resp.type);
    if (j.find("payload") != j.end() && !j.at("payload").is_null())
        j.at("payload").get_to<std::string>(resp.payload);
    if (j.find("from") != j.end() && !j.at("from").is_null())
        j.at("from").get_to<minter::address_t>(resp.from);
    if (j.find("data") != j.end() && !j.at("data").is_null())
        ::minter::explorer::transaction_item::_data_decode(j, resp);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::transaction_item& resp) {
    j = nlohmann::json{
        {"txn", resp.txn},
        {"hash", resp.hash},
        {"nonce", resp.nonce},
        {"block", resp.block},
        {"timestamp", resp.timestamp},
        {"fee", resp.fee},
        {"type", resp.type},
        {"payload", resp.payload},
        {"from", resp.from},
        {"data", ::minter::explorer::transaction_item::_data_encode(j, resp)},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_send_result& resp) {
    if (j.find("to") != j.end() && !j.at("to").is_null())
        j.at("to").get_to<minter::address_t>(resp.to);
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("value") != j.end() && !j.at("value").is_null())
        j.at("value").get_to<dev::bigdec18>(resp.value);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_send_result& resp) {
    j = nlohmann::json{
        {"to", resp.to},
        {"coin", resp.coin},
        {"value", resp.value},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_create_coin_result& resp) {
    if (j.find("name") != j.end() && !j.at("name").is_null())
        j.at("name").get_to<std::string>(resp.name);
    if (j.find("symbol") != j.end() && !j.at("symbol").is_null())
        j.at("symbol").get_to<std::string>(resp.symbol);
    if (j.find("initial_amount") != j.end() && !j.at("initial_amount").is_null())
        j.at("initial_amount").get_to<dev::bigdec18>(resp.initial_amount);
    if (j.find("initial_reserve") != j.end() && !j.at("initial_reserve").is_null())
        j.at("initial_reserve").get_to<dev::bigdec18>(resp.initial_reserve);
    if (j.find("constant_reserve_ratio") != j.end() && !j.at("constant_reserve_ratio").is_null())
        j.at("constant_reserve_ratio").get_to<uint32_t>(resp.crr);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_create_coin_result& resp) {
    j = nlohmann::json{
        {"name", resp.name},
        {"symbol", resp.symbol},
        {"initial_amount", resp.initial_amount},
        {"initial_reserve", resp.initial_reserve},
        {"constant_reserve_ratio", resp.crr},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_convert_result& resp) {
    if (j.find("coin_to_sell") != j.end() && !j.at("coin_to_sell").is_null())
        j.at("coin_to_sell").get_to<std::string>(resp.coin_to_sell);
    if (j.find("coin_to_buy") != j.end() && !j.at("coin_to_buy").is_null())
        j.at("coin_to_buy").get_to<std::string>(resp.coin_to_buy);
    if (j.find("value_to_buy") != j.end() && !j.at("value_to_buy").is_null())
        j.at("value_to_buy").get_to<dev::bigdec18>(resp.value_to_buy);
    if (j.find("value_to_sell") != j.end() && !j.at("value_to_sell").is_null())
        j.at("value_to_sell").get_to<dev::bigdec18>(resp.value_to_sell);
    if (j.find("maximum_value_to_sell") != j.end() && !j.at("maximum_value_to_sell").is_null())
        j.at("maximum_value_to_sell").get_to<dev::bigdec18>(resp.maximum_value_to_sell);
    if (j.find("minimum_value_to_buy") != j.end() && !j.at("minimum_value_to_buy").is_null())
        j.at("minimum_value_to_buy").get_to<dev::bigdec18>(resp.minimum_value_to_buy);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_convert_result& resp) {
    j = nlohmann::json{
        {"coin_to_sell", resp.coin_to_sell},
        {"coin_to_buy", resp.coin_to_buy},
        {"value_to_buy", resp.value_to_buy},
        {"value_to_sell", resp.value_to_sell},
        {"maximum_value_to_sell", resp.maximum_value_to_sell},
        {"minimum_value_to_buy", resp.minimum_value_to_buy},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_declare_candidacy_result& resp) {
    if (j.find("address") != j.end() && !j.at("address").is_null())
        j.at("address").get_to<minter::address_t>(resp.address);
    if (j.find("pub_key") != j.end() && !j.at("pub_key").is_null())
        j.at("pub_key").get_to<minter::pubkey_t>(resp.pub_key);
    if (j.find("commission") != j.end() && !j.at("commission").is_null())
        j.at("commission").get_to<uint32_t>(resp.commission);
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("stake") != j.end() && !j.at("stake").is_null())
        j.at("stake").get_to<dev::bigdec18>(resp.stake);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_declare_candidacy_result& resp) {
    j = nlohmann::json{
        {"address", resp.address},
        {"pub_key", resp.pub_key},
        {"commission", resp.commission},
        {"coin", resp.coin},
        {"stake", resp.stake},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_set_candidate_on_off_result& resp) {
    if (j.find("pub_key") != j.end() && !j.at("pub_key").is_null())
        j.at("pub_key").get_to<minter::pubkey_t>(resp.pub_key);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_set_candidate_on_off_result& resp) {
    j = nlohmann::json{
        {"pub_key", resp.pub_key},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_delegate_unbond_result& resp) {
    if (j.find("pub_key") != j.end() && !j.at("pub_key").is_null())
        j.at("pub_key").get_to<minter::pubkey_t>(resp.pub_key);
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("stake") != j.end() && !j.at("stake").is_null())
        j.at("stake").get_to<dev::bigdec18>(resp.stake);
    if (j.find("value") != j.end() && !j.at("value").is_null())
        j.at("value").get_to<dev::bigdec18>(resp.value);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_delegate_unbond_result& resp) {
    j = nlohmann::json{
        {"pub_key", resp.pub_key},
        {"coin", resp.coin},
        {"stake", resp.stake},
        {"value", resp.value},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_check_data_result& resp) {
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("nonce") != j.end() && !j.at("nonce").is_null())
        j.at("nonce").get_to<dev::bigint>(resp.nonce);
    if (j.find("value") != j.end() && !j.at("value").is_null())
        j.at("value").get_to<dev::bigdec18>(resp.value);
    if (j.find("sender") != j.end() && !j.at("sender").is_null())
        j.at("sender").get_to<minter::address_t>(resp.sender);
    if (j.find("due_block") != j.end() && !j.at("due_block").is_null())
        j.at("due_block").get_to<dev::bigint>(resp.due_block);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_check_data_result& resp) {
    j = nlohmann::json{
        {"coin", resp.coin},
        {"nonce", resp.nonce},
        {"value", resp.value},
        {"sender", resp.sender},
        {"due_block", resp.due_block},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_redeem_check_result& resp) {
    if (j.find("raw_check") != j.end() && !j.at("raw_check").is_null())
        j.at("raw_check").get_to<std::string>(resp.raw_check);
    if (j.find("proof") != j.end() && !j.at("proof").is_null())
        j.at("proof").get_to<std::string>(resp.proof);
    if (j.find("stake") != j.end() && !j.at("stake").is_null())
        j.at("stake").get_to<dev::bigdec18>(resp.stake);
    if (j.find("value") != j.end() && !j.at("value").is_null())
        j.at("value").get_to<dev::bigdec18>(resp.value);
    if (j.find("check") != j.end() && !j.at("check").is_null())
        j.at("check").get_to<tx_check_data_result>(resp.check);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_redeem_check_result& resp) {
    j = nlohmann::json{
        {"raw_check", resp.raw_check},
        {"proof", resp.proof},
        {"stake", resp.stake},
        {"value", resp.value},
        {"check", resp.check},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_create_multisig_result& resp) {
    if (j.find("threshold") != j.end() && !j.at("threshold").is_null())
        j.at("threshold").get_to<dev::bigint>(resp.threshold);
    if (j.find("weights") != j.end() && !j.at("weights").is_null())
        j.at("weights").get_to<std::vector<dev::bigint>>(resp.weights);
    if (j.find("addresses") != j.end() && !j.at("addresses").is_null())
        j.at("addresses").get_to<std::vector<minter::address_t>>(resp.addresses);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_create_multisig_result& resp) {
    j = nlohmann::json{
        {"threshold", resp.threshold},
        {"weights", resp.weights},
        {"addresses", resp.addresses},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_multisend_result& resp) {
    if (j.find("list") != j.end() && !j.at("list").is_null())
        j.at("list").get_to<std::vector<tx_send_result>>(resp.items);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_multisend_result& resp) {
    j = nlohmann::json{
        {"list", resp.items},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::tx_edit_candidate_result& resp) {
    if (j.find("reward_address") != j.end() && !j.at("reward_address").is_null())
        j.at("reward_address").get_to<minter::address_t>(resp.reward_address);
    if (j.find("owner_address") != j.end() && !j.at("owner_address").is_null())
        j.at("owner_address").get_to<minter::address_t>(resp.owner_address);
    if (j.find("pub_key") != j.end() && !j.at("pub_key").is_null())
        j.at("pub_key").get_to<minter::pubkey_t>(resp.pub_key);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::tx_edit_candidate_result& resp) {
    j = nlohmann::json{
        {"reward_address", resp.reward_address},
        {"owner_address", resp.owner_address},
        {"pub_key", resp.pub_key},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::balance_item& resp) {
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("amount") != j.end() && !j.at("amount").is_null())
        j.at("amount").get_to<dev::bigdec18>(resp.amount);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::balance_item& resp) {
    j = nlohmann::json{
        {"coin", resp.coin},
        {"amount", resp.amount},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::balance_items& resp) {
    if (j.find("address") != j.end() && !j.at("address").is_null())
        j.at("address").get_to<minter::address_t>(resp.address);
    if (j.find("balances") != j.end() && !j.at("balances").is_null())
        j.at("balances").get_to<std::vector<balance_item>>(resp.balances);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::balance_items& resp) {
    j = nlohmann::json{
        {"address", resp.address},
        {"balances", resp.balances},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::delegated_item& resp) {
    if (j.find("pub_key") != j.end() && !j.at("pub_key").is_null())
        j.at("pub_key").get_to<minter::pubkey_t>(resp.pub_key);
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("value") != j.end() && !j.at("value").is_null())
        j.at("value").get_to<dev::bigdec18>(resp.value);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::delegated_item& resp) {
    j = nlohmann::json{
        {"pub_key", resp.pub_key},
        {"coin", resp.coin},
        {"value", resp.value},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::reward_item& resp) {
    if (j.find("block") != j.end() && !j.at("block").is_null())
        j.at("block").get_to<uint64_t>(resp.block);
    if (j.find("role") != j.end() && !j.at("role").is_null())
        j.at("role").get_to<std::string>(resp.role);
    if (j.find("amount") != j.end() && !j.at("amount").is_null())
        j.at("amount").get_to<dev::bigdec18>(resp.amount);
    if (j.find("address") != j.end() && !j.at("address").is_null())
        j.at("address").get_to<minter::address_t>(resp.address);
    if (j.find("validator") != j.end() && !j.at("validator").is_null())
        j.at("validator").get_to<minter::pubkey_t>(resp.validator);
    if (j.find("timestamp") != j.end() && !j.at("timestamp").is_null())
        j.at("timestamp").get_to<std::string>(resp.timestamp);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::reward_item& resp) {
    j = nlohmann::json{
        {"block", resp.block},
        {"role", resp.role},
        {"amount", resp.amount},
        {"address", resp.address},
        {"validator", resp.validator},
        {"timestamp", resp.timestamp},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::validator_meta& resp) {
    if (j.find("name") != j.end() && !j.at("name").is_null())
        j.at("name").get_to<std::string>(resp.name);
    if (j.find("description") != j.end() && !j.at("description").is_null())
        j.at("description").get_to<std::string>(resp.description);
    if (j.find("site_url") != j.end() && !j.at("site_url").is_null())
        j.at("site_url").get_to<std::string>(resp.site_url);
    if (j.find("icon_url") != j.end() && !j.at("icon_url").is_null())
        j.at("icon_url").get_to<std::string>(resp.icon_url);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::validator_meta& resp) {
    j = nlohmann::json{
        {"name", resp.name},
        {"description", resp.description},
        {"site_url", resp.site_url},
        {"icon_url", resp.icon_url},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::block_validator_item& resp) {
    if (j.find("publicKey") != j.end() && !j.at("publicKey").is_null())
        j.at("publicKey").get_to<minter::pubkey_t>(resp.pub_key);
    if (j.find("signed") != j.end() && !j.at("signed").is_null())
        j.at("signed").get_to<bool>(resp.is_signed);
    if (j.find("meta") != j.end() && !j.at("meta").is_null())
        j.at("meta").get_to<validator_meta>(resp.meta);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::block_validator_item& resp) {
    j = nlohmann::json{
        {"publicKey", resp.pub_key},
        {"signed", resp.is_signed},
        {"meta", resp.meta},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::block_info_item& resp) {
    if (j.find("height") != j.end() && !j.at("height").is_null())
        j.at("height").get_to<dev::bigint>(resp.height);
    if (j.find("size") != j.end() && !j.at("size").is_null())
        j.at("size").get_to<size_t>(resp.size);
    if (j.find("txCount") != j.end() && !j.at("txCount").is_null())
        j.at("txCount").get_to<size_t>(resp.tx_count);
    if (j.find("blockTime") != j.end() && !j.at("blockTime").is_null())
        j.at("blockTime").get_to<std::string>(resp.block_time);
    if (j.find("timestamp") != j.end() && !j.at("timestamp").is_null())
        j.at("timestamp").get_to<std::string>(resp.timestamp);
    if (j.find("reward") != j.end() && !j.at("reward").is_null())
        j.at("reward").get_to<dev::bigdec18>(resp.reward);
    if (j.find("hash") != j.end() && !j.at("hash").is_null())
        j.at("hash").get_to<minter::hash_t>(resp.hash);
    if (j.find("validators") != j.end() && !j.at("validators").is_null())
        j.at("validators").get_to<std::vector<block_validator_item>>(resp.validators);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::block_info_item& resp) {
    j = nlohmann::json{
        {"height", resp.height},
        {"size", resp.size},
        {"txCount", resp.tx_count},
        {"blockTime", resp.block_time},
        {"timestamp", resp.timestamp},
        {"reward", resp.reward},
        {"hash", resp.hash},
        {"validators", resp.validators},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::coin_item& resp) {
    if (j.find("crr") != j.end() && !j.at("crr").is_null())
        j.at("crr").get_to<uint32_t>(resp.crr);
    if (j.find("volume") != j.end() && !j.at("volume").is_null())
        j.at("volume").get_to<dev::bigdec18>(resp.volume);
    if (j.find("reserve_valance") != j.end() && !j.at("reserve_valance").is_null())
        j.at("reserve_valance").get_to<dev::bigdec18>(resp.reserve_valance);
    if (j.find("name") != j.end() && !j.at("name").is_null())
        j.at("name").get_to<std::string>(resp.name);
    if (j.find("symbol") != j.end() && !j.at("symbol").is_null())
        j.at("symbol").get_to<std::string>(resp.ticker);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::coin_item& resp) {
    j = nlohmann::json{
        {"crr", resp.crr},
        {"volume", resp.volume},
        {"reserve_valance", resp.reserve_valance},
        {"name", resp.name},
        {"symbol", resp.ticker},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::validator_item& resp) {
    if (j.find("public_key") != j.end() && !j.at("public_key").is_null())
        j.at("public_key").get_to<minter::pubkey_t>(resp.pub_key);
    if (j.find("status") != j.end() && !j.at("status").is_null())
        j.at("status").get_to<int>(resp.status);
    if (j.find("stake") != j.end() && !j.at("stake").is_null())
        j.at("stake").get_to<dev::bigdec18>(resp.stake);
    if (j.find("part") != j.end() && !j.at("part").is_null())
        j.at("part").get_to<dev::bigdec18>(resp.part);
    if (j.find("meta") != j.end() && !j.at("meta").is_null())
        j.at("meta").get_to<validator_meta>(resp.meta);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::validator_item& resp) {
    j = nlohmann::json{
        {"public_key", resp.pub_key},
        {"status", resp.status},
        {"stake", resp.stake},
        {"part", resp.part},
        {"meta", resp.meta},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::delegator_item& resp) {
    if (j.find("coin") != j.end() && !j.at("coin").is_null())
        j.at("coin").get_to<std::string>(resp.coin);
    if (j.find("address") != j.end() && !j.at("address").is_null())
        j.at("address").get_to<minter::address_t>(resp.address);
    if (j.find("value") != j.end() && !j.at("value").is_null())
        j.at("value").get_to<dev::bigdec18>(resp.value);
    if (j.find("bip_value") != j.end() && !j.at("bip_value").is_null())
        j.at("bip_value").get_to<dev::bigdec18>(resp.bip_value);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::delegator_item& resp) {
    j = nlohmann::json{
        {"coin", resp.coin},
        {"address", resp.address},
        {"value", resp.value},
        {"bip_value", resp.bip_value},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::validator_detailed_item& resp) {
    if (j.find("public_key") != j.end() && !j.at("public_key").is_null())
        j.at("public_key").get_to<minter::pubkey_t>(resp.pub_key);
    if (j.find("status") != j.end() && !j.at("status").is_null())
        j.at("status").get_to<int>(resp.status);
    if (j.find("stake") != j.end() && !j.at("stake").is_null())
        j.at("stake").get_to<dev::bigdec18>(resp.stake);
    if (j.find("part") != j.end() && !j.at("part").is_null())
        j.at("part").get_to<dev::bigdec18>(resp.part);
    if (j.find("meta") != j.end() && !j.at("meta").is_null())
        j.at("meta").get_to<validator_meta>(resp.meta);
    if (j.find("delegator_count") != j.end() && !j.at("delegator_count").is_null())
        j.at("delegator_count").get_to<uint64_t>(resp.delegator_count);
    if (j.find("delegator_list") != j.end() && !j.at("delegator_list").is_null())
        j.at("delegator_list").get_to<std::vector<delegator_item>>(resp.delegator_list);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::validator_detailed_item& resp) {
    j = nlohmann::json{
        {"public_key", resp.pub_key},
        {"status", resp.status},
        {"stake", resp.stake},
        {"part", resp.part},
        {"meta", resp.meta},
        {"delegator_count", resp.delegator_count},
        {"delegator_list", resp.delegator_list},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::net_status& resp) {
    if (j.find("averageBlockTime") != j.end() && !j.at("averageBlockTime").is_null())
        j.at("averageBlockTime").get_to<dev::bigdec18>(resp.avg_block_time);
    if (j.find("bipPriceChange") != j.end() && !j.at("bipPriceChange").is_null())
        j.at("bipPriceChange").get_to<double>(resp.bip_price_change);
    if (j.find("bipPriceUsd") != j.end() && !j.at("bipPriceUsd").is_null())
        j.at("bipPriceUsd").get_to<double>(resp.bip_price_usd);
    if (j.find("latestBlockHeight") != j.end() && !j.at("latestBlockHeight").is_null())
        j.at("latestBlockHeight").get_to<dev::bigint>(resp.latest_block_height);
    if (j.find("marketCap") != j.end() && !j.at("marketCap").is_null())
        j.at("marketCap").get_to<double>(resp.bip_market_cap);
    if (j.find("totalTransactions") != j.end() && !j.at("totalTransactions").is_null())
        j.at("totalTransactions").get_to<dev::bigint>(resp.total_txn);
    if (j.find("transactionsPerSecond") != j.end() && !j.at("transactionsPerSecond").is_null())
        j.at("transactionsPerSecond").get_to<double>(resp.tx_per_second);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::net_status& resp) {
    j = nlohmann::json{
        {"averageBlockTime", resp.avg_block_time},
        {"bipPriceChange", resp.bip_price_change},
        {"bipPriceUsd", resp.bip_price_usd},
        {"latestBlockHeight", resp.latest_block_height},
        {"marketCap", resp.bip_market_cap},
        {"totalTransactions", resp.total_txn},
        {"transactionsPerSecond", resp.tx_per_second},
    };
}
inline void from_json(const nlohmann::json& j, ::minter::explorer::net_status_page& resp) {
    if (j.find("activeCandidates") != j.end() && !j.at("activeCandidates").is_null())
        j.at("activeCandidates").get_to<uint64_t>(resp.active_candidates);
    if (j.find("activeValidators") != j.end() && !j.at("activeValidators").is_null())
        j.at("activeValidators").get_to<uint64_t>(resp.active_validators);
    if (j.find("averageTxCommission") != j.end() && !j.at("averageTxCommission").is_null())
        j.at("averageTxCommission").get_to<dev::bigdec18>(resp.avg_tx_commission);
    if (j.find("bipEmission") != j.end() && !j.at("bipEmission").is_null())
        j.at("bipEmission").get_to<dev::bigint>(resp.bip_emission);
    if (j.find("blockSpeed24h") != j.end() && !j.at("blockSpeed24h").is_null())
        j.at("blockSpeed24h").get_to<dev::bigdec18>(resp.block_speed_24h);
    if (j.find("customCoinsCount") != j.end() && !j.at("customCoinsCount").is_null())
        j.at("customCoinsCount").get_to<uint64_t>(resp.custom_coins_count);
    if (j.find("customCoinsSum") != j.end() && !j.at("customCoinsSum").is_null())
        j.at("customCoinsSum").get_to<dev::bigdec18>(resp.custom_coins_sum);
    if (j.find("freeFloatBip") != j.end() && !j.at("freeFloatBip").is_null())
        j.at("freeFloatBip").get_to<dev::bigdec18>(resp.bip_free_float);
    if (j.find("numberOfBlocks") != j.end() && !j.at("numberOfBlocks").is_null())
        j.at("numberOfBlocks").get_to<dev::bigint>(resp.number_of_blocks);
    if (j.find("status") != j.end() && !j.at("status").is_null())
        j.at("status").get_to<std::string>(resp.status);
    if (j.find("totalCommission") != j.end() && !j.at("totalCommission").is_null())
        j.at("totalCommission").get_to<dev::bigdec18>(resp.total_commission);
    if (j.find("totalDelegatedBip") != j.end() && !j.at("totalDelegatedBip").is_null())
        j.at("totalDelegatedBip").get_to<dev::bigdec18>(resp.total_delegated_bip);
    if (j.find("tx24hCount") != j.end() && !j.at("tx24hCount").is_null())
        j.at("tx24hCount").get_to<dev::bigint>(resp.tx_24h_count);
    if (j.find("txPerSecond") != j.end() && !j.at("txPerSecond").is_null())
        j.at("txPerSecond").get_to<dev::bigdec18>(resp.tx_per_second);
    if (j.find("txTotalCount") != j.end() && !j.at("txTotalCount").is_null())
        j.at("txTotalCount").get_to<dev::bigint>(resp.total_txn);
    if (j.find("uptime") != j.end() && !j.at("uptime").is_null())
        j.at("uptime").get_to<double>(resp.uptime);
}
inline void to_json(nlohmann::json& j, const ::minter::explorer::net_status_page& resp) {
    j = nlohmann::json{
        {"activeCandidates", resp.active_candidates},
        {"activeValidators", resp.active_validators},
        {"averageTxCommission", resp.avg_tx_commission},
        {"bipEmission", resp.bip_emission},
        {"blockSpeed24h", resp.block_speed_24h},
        {"customCoinsCount", resp.custom_coins_count},
        {"customCoinsSum", resp.custom_coins_sum},
        {"freeFloatBip", resp.bip_free_float},
        {"numberOfBlocks", resp.number_of_blocks},
        {"status", resp.status},
        {"totalCommission", resp.total_commission},
        {"totalDelegatedBip", resp.total_delegated_bip},
        {"tx24hCount", resp.tx_24h_count},
        {"txPerSecond", resp.tx_per_second},
        {"txTotalCount", resp.total_txn},
        {"uptime", resp.uptime},
    };
}

} // namespace explorer
} // namespace minter

#endif
