/*!
 * minter-api.
 * main.cpp
 *
 * \date 2019
 * \author Eduard Maximovich (edward.vstock@gmail.com)
 * \link   https://github.com/edwardstock
 */

#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>
#include <deque>
#include <fmt/format.h>
#include <fstream>
#include <iostream>
#include <nlohmann/json.hpp>
#include <string>
#include <toolbox/strings.hpp>
#include <utility>
#include <vector>

namespace po = boost::program_options;
namespace fs = boost::filesystem;

struct field_item {
    std::string type;
    std::string name;
    std::string serialized_name;
    bool custom_encode_decode = false;
    // useful for derived structs where base class has needed fields
    bool decode_only_field = false;
};

struct type_out {
    std::string name;
    std::string parent;
    std::vector<field_item*> fields;
    std::vector<field_item*> parent_fields;
    std::unordered_map<std::string, field_item*> named_fields;
    std::vector<std::string> custom_rows;
};

struct file_out {
    std::vector<std::string> includes;
    std::vector<std::string> cppincludes;
    std::vector<type_out*> types;
};

class printer {
public:
    printer(std::ostream& s, std::ostream& cpp_s, const std::string& def_name, std::vector<std::string>&& namespaces)
        : header_s(s), cpp_s(cpp_s),
          ns(std::move(namespaces)),
          def_name(def_name) {
    }

    printer& begin(const std::vector<std::string>& includes, const std::vector<std::string>& cppincludes) {
        header_s << "#ifndef " << def_name << "\n";
        header_s << "#define " << def_name << "\n";
        header_s << R"(
// AUTOGENERATED header. DO NOT modify manually.
//
)";
        cpp_s << R"(
// AUTOGENERATED cpp. DO NOT modify manually.
//
)";
        for (const auto& in : includes) {
            add_include(header_s, in);
        }
        for (const auto& in : cppincludes) {
            add_include(cpp_s, in);
        }
        if (ns.size()) {
            header_s << "\n\n";
            for (const auto& n : ns) {
                header_s << "\nnamespace " << n << " {";
            }

            header_s << "\n";
        }

        return *this;
    }

    std::string get_ns() {
        if (!ns.size()) {
            return std::string();
        }

        std::stringstream ss;
        ss << "::";
        for (const auto& n : ns) {
            ss << n << "::";
        }

        return ss.str();
    }

    printer& add_include(std::ostream& stream, const std::string& include) {
        if (!include.length()) {
            return *this;
        }

        if (include[0] != '<') {
            stream << fmt::format("#include \"{0}\"\n", include);
        } else {
            stream << fmt::format("#include {0}\n", include);
        }

        return *this;
    }

    printer& create_struct(type_out* type) {
        structs.push_back(type);
        return *this;
    }

    printer& end() {
        std::deque<type_out*> tmp;
        while (!structs.empty()) {
            type_out* type = structs.front();
            structs.pop_front();
            tmp.push_back(type);

            header_s << "\n";
            header_s << "struct " << type->name;
            if (!type->parent.empty()) {
                header_s << " : public " << type->parent << " ";
            }
            header_s << " {";

            for (const auto& field : type->fields) {
                // don't add exceed field as it already contains in base class
                if (!field->decode_only_field) {
                    header_s << "\n\t" << field->type << " " << field->serialized_name << ";";
                }

                if (field->custom_encode_decode) {
                    type->custom_rows.push_back(fmt::format(
                        R"(static ::nlohmann::json _{0}_encode(nlohmann::json &j, const {1}& resp))", field->name, get_ns() + type->name));
                    type->custom_rows.push_back(fmt::format(
                        R"(static void _{0}_decode(const nlohmann::json &j, {1}& resp))", field->name, get_ns() + type->name));
                }
            }

            for (const auto& custom : type->custom_rows) {
                header_s << "\n\t" << custom << ";";
            }
            header_s << "\n};";
        }

        while (!tmp.empty()) {
            type_out* type = tmp.front();
            generate_json_bindings(type);
            tmp.pop_front();
        }

        if (!ns.empty()) {
            header_s << "\n\n";
            for (auto n = ns.rbegin(); n != ns.rend(); ++n) {
                header_s << "\n} // " << (*n);
            }
        }

        header_s << "\n\n#endif\n";
        return *this;
    }

    printer& generate_json_bindings(type_out* type) {
        const auto ns_w_type = get_ns() + type->name;
        // create header definition of from_json
        header_s << "\n"
                 << fmt::format("MINTER_TX_API void from_json(const nlohmann::json& j, {0}& resp);", ns_w_type);

        // then create cpp implementation
        cpp_s << "\n"
              << fmt::format("void {0}from_json(const nlohmann::json& j, {1}& resp) {{", get_ns(), ns_w_type);

        for (const auto& field : type->fields) {
            if (!field->custom_encode_decode) {
                cpp_s << "\n\t" << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) j.at("{0}").get_to<{1}>(resp.{2});)", field->name, field->type, field->serialized_name);
            } else {
                cpp_s << "\n\t";
                cpp_s << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) )", field->name);
                cpp_s << fmt::format(R"({0}{1}::_{2}_decode(j, resp);)", get_ns(), type->name, field->serialized_name);
            }
        }

        for (const auto& parent_field : type->parent_fields) {
            if (!parent_field->custom_encode_decode) {
                cpp_s << "\n\t" << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) j.at("{0}").get_to<{1}>(resp.{2});)", parent_field->name, parent_field->type, parent_field->serialized_name);
            } else {
                cpp_s << "\n\t";
                cpp_s << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) )", parent_field->name);
                cpp_s << fmt::format(R"({0}{1}::_{2}_decode(j, resp);)", get_ns(), type->name, parent_field->serialized_name);
            }
        }

        cpp_s << "\n}";

        // create header definition of to_json
        header_s << "\n"
                 << fmt::format("MINTER_TX_API void to_json(nlohmann::json& j, const {0}& resp);", ns_w_type);

        // then create cpp implementation
        cpp_s << "\n"
                 "void "
              << get_ns() << "to_json(nlohmann::json& j, const " << ns_w_type << "& resp) {";

        cpp_s << "\n\t";
        cpp_s << "j = nlohmann::json{";
        for (const auto& field : type->fields) {
            cpp_s << "\n\t\t";
            if (!field->custom_encode_decode) {
                cpp_s << fmt::format(R"({{"{0}", resp.{1}}},)", field->name, field->serialized_name);
            } else {
                cpp_s << fmt::format(R"({{"{0}", {1}{2}::_{3}_encode(j, resp)}},)",
                                     field->name,
                                     get_ns(),
                                     type->name,
                                     field->serialized_name);
            }
        }
        for (const auto& parent_field : type->parent_fields) {
            cpp_s << "\n\t\t";
            if (!parent_field->custom_encode_decode) {
                cpp_s << fmt::format(R"({{"{0}", resp.{1}}},)", parent_field->name, parent_field->serialized_name);
            } else {
                cpp_s << fmt::format(R"({{"{0}", {1}{2}::_{3}_encode(j, resp)}},)",
                                     parent_field->name,
                                     get_ns(),
                                     type->name,
                                     parent_field->serialized_name);
            }
        }
        cpp_s << "\n\t};";
        cpp_s << "\n}";

        return *this;
    }

private:
    std::deque<type_out*> structs;
    std::ostream& header_s;
    std::ostream& cpp_s;
    std::vector<std::string> ns;
    std::string def_name;
};

struct source_file {
    fs::path path;
    fs::path target_path;
    fs::path cpptarget_path;
    std::string filename;
};

int main(int argc, char** argv) {

    po::options_description desc("Allowed options");
    desc.add_options()("help", "produce help message")("source,S", po::value<std::string>(), "json descriptors source path")("target,T", po::value<std::string>(), "target generated path")("cpptarget, C", po::value<std::string>(), "target for cpp implementation file")("namespaces,N", po::value<std::vector<std::string>>(), "target namespace");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    if (!vm.count("source") || !vm.count("target") || !vm.count("cpptarget")) {
        std::cout << "\t--source, --target and --cpptarget required !\n";
        std::cout << desc << "\n";
        return 1;
    }

    if (vm.count("help")) {
        std::cout << desc << "\n";
        return 0;
    }

    const std::string target_path = vm.at("target").as<std::string>();
    const fs::path target_dir(target_path);

    const std::string cpptarget_path = vm.at("cpptarget").as<std::string>();
    const fs::path cpptarget_dir(cpptarget_path);

    const std::string search_path = vm.at("source").as<std::string>();
    const fs::path search_dir(search_path);

    std::string dirsep;
    dirsep.resize(1);
    dirsep[0] = fs::path::preferred_separator;

    std::cout << "Asset root: " << search_path << "\n";

    if (!fs::is_directory(search_dir)) {
        throw std::runtime_error("source dir " + search_path + " is not a directory");
    }

    if (!fs::is_directory(target_path)) {
        throw std::runtime_error("target dir " + search_path + " is not a directory");
    }

    std::vector<source_file> source_files;
    fs::directory_iterator end_iter;

    auto dir_itr = fs::directory_iterator(search_dir);

    while (dir_itr != end_iter) {

        if (fs::is_regular_file(*dir_itr)) {
            if (dir_itr->path().extension() == ".json") {

                std::string filename = toolbox::strings::substr_replace_ret(".json", "", dir_itr->path().filename().string());
                std::cout << "Found asset " << filename << "\n";
                source_files.emplace_back(source_file{
                    dir_itr->path().string(),
                    fs::path(target_dir.string() + dirsep + filename),
                    fs::path(cpptarget_dir.string() + dirsep + filename),
                    filename});
            } else {
                std::cout << "Skipping asset " << dir_itr->path().c_str() << "\n";
            }
        }

        ++dir_itr;
    }

    for (const auto& source : source_files) {
        nlohmann::json j;
        std::ifstream is(source.path.string(), std::ios::in);
        if (!is.is_open()) {
            std::cerr << "Can't open file " << source.path << "\n";
            return 1;
        }

        if (!fs::is_directory(source.target_path)) {
            bool created = fs::create_directories(source.target_path);
            if (!created) {
                std::cerr << "target \"" << source.target_path << "\" is not a directory"
                          << "\n";
            }

            return 1;
        }
        if (!fs::is_directory(source.cpptarget_path)) {
            bool created = fs::create_directories(source.cpptarget_path);
            if (!created) {
                std::cerr << "target \"" << source.cpptarget_path << "\" is not a directory"
                          << "\n";
            }

            return 1;
        }
        std::ofstream of(source.target_path.string() + dirsep + source.filename + "_results.h", std::ios::out);
        std::ofstream cpp_of(source.cpptarget_path.string() + dirsep + source.filename + "_results.cpp", std::ios::out);

        is >> j;

        file_out out;

        j.at("includes").get_to(out.includes);
        if (j.find("cppincludes") != j.end() && !j.at("cppincludes").is_null()) {
            j.at("cppincludes").get_to(out.cppincludes);
        } else {
            out.cppincludes.resize(0);
        }

        auto struct_item = j.at("responses");

        std::unordered_map<std::string, std::vector<type_out*>> children_to_copy;
        const std::string create_namespace = "minter::" + source.filename + "::";

        for (const auto& item : struct_item) {
            type_out* type = new type_out;
            item.at("name").get_to<std::string>(type->name);
            if (item.find("parent") != item.end()) {
                item.at("parent").get_to<std::string>(type->parent);
            } else if (item.find("copyParent") != item.end()) {
                item.at("copyParent").get_to<std::string>(type->parent);
            }
            for (const nlohmann::json& field : item.at("fields")) {

                std::string f_type, f_name, f_serialized_name;
                bool f_custom_encode_decode = false;
                bool f_decode_only_field = false;

                f_type = field[0].get<std::string>();
                f_name = field[1].get<std::string>();

                if (field.size() >= 3 && field[2].get<std::string>() != "") {
                    f_serialized_name = field[2].get<std::string>();
                } else {
                    f_serialized_name = f_name;
                }
                if (field.size() >= 4 && field[3].is_boolean()) {
                    f_custom_encode_decode = field[3].get<bool>();
                }
                if (field.size() >= 5 && field[4].is_boolean()) {
                    f_decode_only_field = true;
                }

                auto* f_item = new field_item;
                f_item->type = f_type;
                f_item->name = f_name;
                f_item->serialized_name = f_serialized_name;
                f_item->custom_encode_decode = f_custom_encode_decode;
                f_item->decode_only_field = f_decode_only_field;
                type->fields.push_back(f_item);

                type->named_fields[type->name] = f_item;
            }

            out.types.push_back(type);

            if (item.find("copyParent") != item.end()) {
                auto parent_to_copy_from = item.at("copyParent").get<std::string>();
                toolbox::strings::replace(create_namespace, "", parent_to_copy_from);
                if (!children_to_copy.count(parent_to_copy_from)) {
                    children_to_copy.insert(std::pair<std::string, std::vector<type_out*>>(parent_to_copy_from, std::vector<type_out*>()));
                }

                children_to_copy.at(parent_to_copy_from).push_back(type);
            }
        }

        for (auto& type : out.types) {
            if (children_to_copy.count(type->name)) {
                auto children = children_to_copy[type->name];
                for (auto& child : children) {
                    if (child->fields.empty()) {
                        std::copy(type->fields.begin(), type->fields.end(), std::back_inserter(child->parent_fields));
                    } else {
                        for (auto& parent_field : type->fields) {
                            if (!child->named_fields.count(parent_field->name)) {
                                child->parent_fields.push_back(parent_field);
                            }
                        }
                    }
                    //                    std::cout << "Found parent " << type->name << " for child " << child->name  << std::endl;;
                }
            }
        }

        printer p(of, cpp_of, toolbox::strings::to_upper_case("GEN_" + source.filename + "_RESULTS"), {"minter", source.filename});
        p.begin(out.includes, out.cppincludes);

        for (const auto& type : out.types) {
            std::cout << "Creating result: " + type->name << "\n";
            p.create_struct(type);
        }

        p.end();

        std::cout << std::endl;

        of.flush();
        of.close();
        cpp_of.flush();
        cpp_of.close();

        for (auto& t : out.types) {
            for (auto& f : t->fields) {
                delete f;
                f = nullptr;
            }
            delete t;
            t = nullptr;
        }
    }
}
