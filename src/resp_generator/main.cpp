/*!
 * minter-api.
 * main.cpp
 *
 * \date 2019
 * \author Eduard Maximovich (edward.vstock@gmail.com)
 * \link   https://github.com/edwardstock
 */

#include <boost/filesystem.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <boost/program_options.hpp>
#include <boost/system/error_code.hpp>
#include <deque>
#include <fmt/format.h>
#include <fstream>
#include <iostream>
#include <nlohmann/json.hpp>
#include <sstream>
#include <string>
#include <toolbox/strings.hpp>
#include <unordered_map>
#include <utility>
#include <vector>

namespace po = boost::program_options;
namespace fs = boost::filesystem;

struct field_item {
    std::string type;
    std::string name;
    std::string serialized_name;
    bool custom_encode_decode = false;
};

struct type_out {
    std::string name;
    std::string parent;
    std::vector<field_item> fields;
    std::vector<std::string> custom_rows;
};

struct file_out {
    std::vector<std::string> includes;
    std::vector<type_out> types;
};

class printer {
public:
    printer(std::ostream& s, const std::string& def_name)
        : s(s),
          def_name(def_name) {
    }
    printer(std::ostream& s, const std::string& def_name, std::vector<std::string>&& namespaces)
        : s(s),
          ns(std::move(namespaces)),
          def_name(def_name) {
    }

    printer& begin(const std::vector<std::string>& includes) {
        s << "#ifndef " << def_name << "\n";
        s << "#define " << def_name << "\n";
        s << R"(
// AUTOGENERATED header. DO NOT modify manually.
//
)";
        for (const auto& in : includes) {
            add_include(in);
        }
        if (ns.size()) {
            s << "\n\n";
            for (const auto& n : ns) {
                s << "\nnamespace " << n << " {";
            }

            s << "\n";
        }

        return *this;
    }

    std::string get_ns() {
        if (!ns.size()) {
            return std::string();
        }

        std::stringstream ss;
        ss << "::";
        for (const auto& n : ns) {
            ss << n << "::";
        }

        return ss.str();
    }

    printer& add_include(const std::string& include) {
        if (!include.length()) {
            return *this;
        }

        if (include[0] != '<') {
            s << fmt::format("#include \"{0}\"\n", include);
        } else {
            s << fmt::format("#include {0}\n", include);
        }

        return *this;
    }

    printer& create_struct(const type_out& type) {
        structs.push_back(type);
        return *this;
    }

    printer& end() {
        std::deque<type_out> tmp;
        while (!structs.empty()) {
            type_out type = structs.front();
            structs.pop_front();
            tmp.push_back(type);

            s << "\n";
            s << "struct " << type.name;
            if (type.parent != "") {
                s << " : public " << type.parent << " ";
            }
            s << " {";

            for (const auto& field : type.fields) {
                s << "\n\t" << field.type << " " << field.serialized_name << ";";

                if (field.custom_encode_decode) {
                    type.custom_rows.push_back(fmt::format(
                        R"(static ::nlohmann::json _{0}_encode(nlohmann::json &j, const {1}& resp))", field.name, get_ns() + type.name));
                    type.custom_rows.push_back(fmt::format(
                        R"(static void _{0}_decode(const nlohmann::json &j, {1}& resp))", field.name, get_ns() + type.name));
                }
            }

            for (const auto& custom : type.custom_rows) {
                s << "\n\t" << custom << ";";
            }
            s << "\n};";
        }

        while (!tmp.empty()) {
            type_out type = tmp.front();
            generate_json_bindings(type);
            tmp.pop_front();
        }

        if (ns.size()) {
            s << "\n\n";
            for (auto n = ns.rbegin(); n != ns.rend(); ++n) {
                s << "\n} // " << (*n);
            }
        }

        s << "\n\n#endif\n";
        return *this;
    }

    printer& generate_json_bindings(const type_out& type) {
        s << "\n"
          << fmt::format("inline void from_json(const nlohmann::json& j, {0}& resp) {{", get_ns() + type.name);

        for (const auto& field : type.fields) {
            if (!field.custom_encode_decode) {
                s << "\n\t" << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) j.at("{0}").get_to<{1}>(resp.{2});)", field.name, field.type, field.serialized_name);
            } else {
                s << "\n\t";
                s << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) )", field.name);
                s << fmt::format(R"({0}{1}::_{2}_decode(j, resp);)", get_ns(), type.name, field.serialized_name);
            }
        }
        s << "\n}";

        s << "\n"
          << fmt::format("inline void to_json(nlohmann::json& j, const {0}& resp) {{", get_ns() + type.name);

        s << "\n\t";
        s << "j = nlohmann::json{";
        for (const auto& field : type.fields) {
            s << "\n\t\t";
            if (!field.custom_encode_decode) {
                s << fmt::format(R"({{"{0}", resp.{1}}},)", field.name, field.serialized_name);
            } else {
                s << fmt::format(R"({{"{0}", {1}{2}::_{3}_encode(j, resp)}},)",
                                 field.name,
                                 get_ns(),
                                 type.name,
                                 field.serialized_name);
            }
        }
        s << "\n\t};";
        s << "\n}";

        return *this;
    }

private:
    std::deque<type_out> structs;
    std::ostream& s;
    std::vector<std::string> ns;
    std::string def_name;
};

struct source_file {
    fs::path path;
    fs::path target_path;
    std::string filename;
};

int main(int argc, char** argv) {

    po::options_description desc("Allowed options");
    desc.add_options()("help", "produce help message")("source,S", po::value<std::string>(), "json descriptors source path")("target,T", po::value<std::string>(), "target generated path")("namespaces,N", po::value<std::vector<std::string>>(), "target namespace");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    if (!vm.count("source") || !vm.count("target")) {
        std::cout << "\t--source and --target required!\n";
        std::cout << desc << "\n";
        return 1;
    }

    if (vm.count("help")) {
        std::cout << desc << "\n";
        return 0;
    }

    const std::string target_path = vm.at("target").as<std::string>();
    const fs::path target_dir(target_path);

    const std::string search_path = vm.at("source").as<std::string>();
    const fs::path search_dir(search_path);

    std::cout << "Asset root: " << search_path << "\n";

    if (!fs::is_directory(search_dir)) {
        throw std::runtime_error("source dir " + search_path + " is not a directory");
    }

    if (!fs::is_directory(target_path)) {
        throw std::runtime_error("target dir " + search_path + " is not a directory");
    }

    std::vector<source_file> source_files;
    fs::directory_iterator end_iter;

    auto dir_itr = fs::directory_iterator(search_dir);
    while (dir_itr != end_iter) {

        if (fs::is_regular_file(*dir_itr)) {
            if (dir_itr->path().extension() == ".json") {

                std::string filename = toolbox::strings::substr_replace_ret(".json", "", dir_itr->path().filename().string());
                std::cout << "Found asset " << filename << "\n";
                source_files.emplace_back(source_file{
                    dir_itr->path().string(),
                    fs::path(target_dir.string() + "/" + filename),
                    filename});
            } else {
                std::cout << "Skipping asset " << dir_itr->path().c_str() << "\n";
            }
        }

        ++dir_itr;
    }

    for (const auto& source : source_files) {
        nlohmann::json j;
        std::ifstream is(source.path.string(), std::ios::in);
        if (!is.is_open()) {
            std::cerr << "Can't open file " << source.path << "\n";
            return 1;
        }

        if (!fs::is_directory(source.target_path)) {
            bool created = fs::create_directories(source.target_path);
            if (!created) {
                std::cerr << "target \"" << source.target_path << "\" is not a directory"
                          << "\n";
            }

            return 1;
        }
        std::ofstream of(source.target_path.string() + "/results.hpp", std::ios::out);
        is >> j;

        file_out out;

        j.at("includes").get_to(out.includes);
        auto struct_item = j.at("responses");
        for (const auto& item : struct_item) {
            type_out type{};
            item.at("name").get_to<std::string>(type.name);
            if (item.find("parent") != item.end()) {
                item.at("parent").get_to<std::string>(type.parent);
            }
            for (const nlohmann::json& field : item.at("fields")) {

                std::string f_type, f_name, f_serialized_name;
                bool f_custom_encode_decode = false;

                f_type = field[0].get<std::string>();
                f_name = field[1].get<std::string>();

                if (field.size() >= 3 && field[2].get<std::string>() != "") {
                    f_serialized_name = field[2].get<std::string>();
                } else {
                    f_serialized_name = f_name;
                }
                if (field.size() >= 4 && field[3].is_boolean()) {
                    f_custom_encode_decode = field[3].get<bool>();
                }

                type.fields.push_back(field_item{
                    f_type,
                    f_name,
                    f_serialized_name,
                    f_custom_encode_decode});
            }

            out.types.push_back(std::move(type));
        }

        printer p(of, toolbox::strings::to_upper_case("GEN_" + source.filename + "_RESULTS"), {"minter", source.filename});
        p.begin(out.includes);

        for (const auto& type : out.types) {
            std::cout << "Creating result: " + type.name << "\n";
            p.create_struct(type);
        }

        p.end();

        std::cout << std::endl;

        of.flush();
        of.close();
    }
}
